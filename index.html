<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>체스 게임</title>
  <style>
    body { display: flex; justify-content: center; align-items: center; height: 100vh; }
    #chessboard {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 2px solid #333;
    }
    .cell {
      width: 60px; height: 60px;
      display: flex; justify-content: center; align-items: center;
      font-size: 2em;
    }
    .white { background: #f0d9b5; }
    .black { background: #b58863; }
    #start-btn {
      font-size: 2em;
      padding: 20px 40px;
      cursor: pointer;
      border-radius: 10px;
      border: 2px solid #333;
      background: #fffbe6;
      box-shadow: 2px 2px 8px #ccc;
    }
  </style>
</head>
<body>
  <div style="position:absolute;top:30px;left:0;right:0;text-align:center;font-size:1.2em;z-index:2;">
    <span>AI(Stockfish)와 체스를 둘 수 있습니다. 흰색(사용자) vs 검은색(AI)</span>
  </div>
  <button id="start-btn">시작</button>
  <div id="chessboard" style="display:none"></div>
  <script>
    const pieces = {
      'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
      'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
    };

    let boardState = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];

    let selected = null;
    let turn = 'white'; // white 또는 black

// 현재 색의 킹이 체크 상태인지 판별
function isKingInCheck(color) {
  // 킹 위치 찾기
  let kingRow = -1, kingCol = -1;
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const p = boardState[row][col];
      if (p && ((color === 'white' && p === 'K') || (color === 'black' && p === 'k'))) {
        kingRow = row;
        kingCol = col;
      }
    }
  }
  if (kingRow === -1) return false;
  // 상대 기물 중 하나라도 킹을 잡을 수 있으면 체크
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const p = boardState[row][col];
      if (!p) continue;
      if ((color === 'white' && isBlack(p)) || (color === 'black' && isWhite(p))) {
        if (basicValidMove({row, col}, {row: kingRow, col: kingCol})) {
          return true;
        }
      }
    }
  }
  return false;
}

// 기물 이동 규칙만 검사(체크 여부 무시)
function basicValidMove(from, to) {
  const piece = boardState[from.row][from.col];
  const target = boardState[to.row][to.col];
  const dr = to.row - from.row;
  const dc = to.col - from.col;
  if (piece && ((isWhite(piece) && isWhite(target)) || (isBlack(piece) && isBlack(target)))) return false;
  if (piece === 'P') {
    if (dc === 0 && dr === -1 && !target) return true;
    if (dc === 0 && dr === -2 && from.row === 6 && !target && !boardState[5][from.col]) return true;
    if (Math.abs(dc) === 1 && dr === -1 && target && isBlack(target)) return true;
    return false;
  }
  if (piece === 'p') {
    if (dc === 0 && dr === 1 && !target) return true;
    if (dc === 0 && dr === 2 && from.row === 1 && !target && !boardState[2][from.col]) return true;
    if (Math.abs(dc) === 1 && dr === 1 && target && isWhite(target)) return true;
    return false;
  }
  if (piece.toLowerCase() === 'r') {
    if (dr === 0 && dc !== 0) {
      const step = dc > 0 ? 1 : -1;
      for (let c = from.col + step; c !== to.col; c += step) {
        if (boardState[from.row][c]) return false;
      }
      return true;
    }
    if (dc === 0 && dr !== 0) {
      const step = dr > 0 ? 1 : -1;
      for (let r = from.row + step; r !== to.row; r += step) {
        if (boardState[r][from.col]) return false;
      }
      return true;
    }
    return false;
  }
  if (piece.toLowerCase() === 'n') {
    if ((Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2)) return true;
    return false;
  }
  if (piece.toLowerCase() === 'b') {
    if (Math.abs(dr) === Math.abs(dc)) {
      const stepR = dr > 0 ? 1 : -1;
      const stepC = dc > 0 ? 1 : -1;
      let r = from.row + stepR, c = from.col + stepC;
      while (r !== to.row && c !== to.col) {
        if (boardState[r][c]) return false;
        r += stepR; c += stepC;
      }
      return true;
    }
    return false;
  }
  if (piece.toLowerCase() === 'q') {
    if (dr === 0 || dc === 0) return basicValidMove(from, to, 'r');
    if (Math.abs(dr) === Math.abs(dc)) return basicValidMove(from, to, 'b');
    return false;
  }
  if (piece.toLowerCase() === 'k') {
    if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return true;
    return false;
  }
  return false;
}

let highlightMoves = [];

// 선택된 기물의 이동 가능한 경로를 반환
function getValidMoves(from) {
  const moves = [];
  const piece = boardState[from.row][from.col];
  const color = isWhite(piece) ? 'white' : 'black';
  const kingChecked = isKingInCheck(color);
  if (!kingChecked) {
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (validMove(from, { row, col })) {
          moves.push({ row, col });
        }
      }
    }
    return moves;
  }
  // 체크 상황이면, 킹이거나 체크를 막거나 잡을 수 있는 수만 허용
  // 1. 킹이면 기존대로 validMove
  if (piece.toLowerCase() === 'k') {
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (validMove(from, { row, col })) {
          moves.push({ row, col });
        }
      }
    }
    return moves;
  }
  // 2. 다른 기물은 실제로 움직여서 체크를 막거나 잡는지 확인
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if (validMove(from, { row, col })) {
        // 임시 이동
        const backup = boardState[row][col];
        const fromBackup = boardState[from.row][from.col];
        boardState[row][col] = fromBackup;
        boardState[from.row][from.col] = '';
        const stillCheck = isKingInCheck(color);
        // 원상복구
        boardState[from.row][from.col] = fromBackup;
        boardState[row][col] = backup;
        if (!stillCheck) {
          moves.push({ row, col });
        }
      }
    }
  }
  return moves;
}

    function isWhite(piece) {
      return piece && piece === piece.toUpperCase();
    }
    function isBlack(piece) {
      return piece && piece === piece.toLowerCase();
    }

    function renderBoard() {
      const board = document.getElementById('chessboard');
      board.innerHTML = '';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell ' + ((row + col) % 2 === 0 ? 'white' : 'black');
          cell.dataset.row = row;
          cell.dataset.col = col;
          if (boardState[row][col]) {
            cell.textContent = pieces[boardState[row][col]];
          }
          if (selected && selected.row === row && selected.col === col) {
            cell.style.outline = '2px solid red';
          }
          // 이동 가능 경로 하이라이트
          if (highlightMoves.some(m => m.row === row && m.col === col)) {
            cell.style.background = '#aaf2a2';
          }
          cell.addEventListener('click', onCellClick);
          board.appendChild(cell);
        }
      }
    }

    function validMove(from, to) {
      // 킹이 이동할 때 이동한 위치가 체크가 되는지 검사 (자살수 방지)
      const piece = boardState[from.row][from.col];
      if (piece && piece.toLowerCase() === 'k') {
        // 임시로 이동
        const backup = boardState[to.row][to.col];
        boardState[to.row][to.col] = piece;
        boardState[from.row][from.col] = '';
        const kingInCheck = isKingInCheck(isWhite(piece) ? 'white' : 'black');
        // 원상복구
        boardState[from.row][from.col] = piece;
        boardState[to.row][to.col] = backup;
        if (kingInCheck) return false;
      }
      const target = boardState[to.row][to.col];
      const dr = to.row - from.row;
      const dc = to.col - from.col;

      // 자기 말로 이동 불가
      if (piece && ((isWhite(piece) && isWhite(target)) || (isBlack(piece) && isBlack(target)))) {
        return false;
      }
  // ...기존 기물 이동 규칙...

  // 킹 이동은 위에서 체크

      // 폰 이동
      if (piece === 'P') {
        if (dc === 0 && dr === -1 && !target) return true;
        if (dc === 0 && dr === -2 && from.row === 6 && !target && !boardState[5][from.col]) return true;
        if (Math.abs(dc) === 1 && dr === -1 && target && isBlack(target)) return true;
        return false;
      }
      if (piece === 'p') {
        if (dc === 0 && dr === 1 && !target) return true;
        if (dc === 0 && dr === 2 && from.row === 1 && !target && !boardState[2][from.col]) return true;
        if (Math.abs(dc) === 1 && dr === 1 && target && isWhite(target)) return true;
        return false;
      }

      // 룩 이동
      if (piece.toLowerCase() === 'r') {
        if (dr === 0 && dc !== 0) {
          const step = dc > 0 ? 1 : -1;
          for (let c = from.col + step; c !== to.col; c += step) {
            if (boardState[from.row][c]) return false;
          }
          return true;
        }
        if (dc === 0 && dr !== 0) {
          const step = dr > 0 ? 1 : -1;
          for (let r = from.row + step; r !== to.row; r += step) {
            if (boardState[r][from.col]) return false;
          }
          return true;
        }
        return false;
      }

      // 나이트 이동
      if (piece.toLowerCase() === 'n') {
        if ((Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2)) {
          return true;
        }
        return false;
      }

      // 비숍 이동
      if (piece.toLowerCase() === 'b') {
        if (Math.abs(dr) === Math.abs(dc)) {
          const stepR = dr > 0 ? 1 : -1;
          const stepC = dc > 0 ? 1 : -1;
          let r = from.row + stepR, c = from.col + stepC;
          while (r !== to.row && c !== to.col) {
            if (boardState[r][c]) return false;
            r += stepR; c += stepC;
          }
          return true;
        }
        return false;
      }

      // 퀸 이동
      if (piece.toLowerCase() === 'q') {
        // 룩 이동
        if (dr === 0 || dc === 0) return validMove(from, to, 'r');
        // 비숍 이동
        if (Math.abs(dr) === Math.abs(dc)) return validMove(from, to, 'b');
        return false;
      }

      // 킹 이동
      if (piece.toLowerCase() === 'k') {
        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return true;
        return false;
      }

      return false;
    }

    function boardToFEN() {
      let fen = '';
      for (let row = 0; row < 8; row++) {
        let empty = 0;
        for (let col = 0; col < 8; col++) {
          const p = boardState[row][col];
          if (p) {
            if (empty > 0) { fen += empty; empty = 0; }
            fen += p;
          } else {
            empty++;
          }
        }
        if (empty > 0) fen += empty;
        if (row < 7) fen += '/';
      }
      fen += ' ' + (turn === 'white' ? 'w' : 'b') + ' - - 0 1';
      return fen;
    }

    async function aiMove() {
      const fen = boardToFEN();
      const res = await fetch('http://localhost:3001/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fen })
      });
      const data = await res.json();
      const move = data.move;
      if (move && move.length >= 4) {
        const from = { row: 8 - Number(move[1]), col: move.charCodeAt(0) - 97 };
        const to = { row: 8 - Number(move[3]), col: move.charCodeAt(2) - 97 };
        boardState[to.row][to.col] = boardState[from.row][from.col];
        boardState[from.row][from.col] = '';
        turn = 'white';
        renderBoard();
      }
    }

    function onCellClick(e) {
      const row = Number(e.currentTarget.dataset.row);
      const col = Number(e.currentTarget.dataset.col);
      const piece = boardState[row][col];
      const color = turn;
      const kingChecked = isKingInCheck(color);

      if (selected) {
        if (validMove(selected, { row, col })) {
          boardState[row][col] = boardState[selected.row][selected.col];
          boardState[selected.row][selected.col] = '';
          turn = turn === 'white' ? 'black' : 'white';
          selected = null;
          highlightMoves = [];
          renderBoard();
          if (turn === 'black') {
            setTimeout(aiMove, 500);
          }
        } else {
          selected = null;
          highlightMoves = [];
          renderBoard();
        }
      } else if (piece && ((turn === 'white' && isWhite(piece)) || (turn === 'black' && isBlack(piece)))) {
        // 체크 상황이면 이동 가능한 기물만 선택 가능
        const moves = getValidMoves({ row, col });
        if (kingChecked && moves.length === 0) {
          // 이동 불가 안내
          alert('체크 상황에서는 킹 또는 체크를 막거나 잡을 수 있는 기물만 이동할 수 있습니다.');
          return;
        }
        selected = { row, col };
        highlightMoves = moves;
        renderBoard();
      }
    }

    // 시작 버튼 클릭 시 체스판 표시
    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('start-btn').style.display = 'none';
      document.getElementById('chessboard').style.display = 'grid';
      renderBoard();
      // 게임 시작 시 흑이 AI면 AI가 둠
      if (turn === 'black') setTimeout(aiMove, 500);
    });
  </script>
</body>
</html>